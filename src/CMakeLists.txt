cmake_minimum_required(VERSION 3.4)

project(fesom C Fortran)

option(DISABLE_MULTITHREADING "disable asynchronous operations" ON)
set(GPU_COMPUTE_CAPABILITY "cc80" CACHE STRING "GPU Arch for PGI Compiler (cc35,cc50,cc60,cc70,cc80,...)")
set(GPU_FLAGS "math_uniform,cuda11.7,${GPU_COMPUTE_CAPABILITY},autocompare" CACHE STRING "Flags to be passed to \"-gpu\" when building gpu code")

# get our source files
set(src_home ${CMAKE_CURRENT_LIST_DIR}) # path to src directory starting from the dir containing our CMakeLists.txt
if(${USE_ICEPACK})
   file(GLOB sources_Fortran ${src_home}/*.F90
                             ${src_home}/icepack_drivers/*.F90
                             ${src_home}/icepack_drivers/Icepack/columnphysics/*.F90)
else()
   file(GLOB sources_Fortran ${src_home}/*.F90)
endif()
#list(REMOVE_ITEM sources_Fortran ${src_home}/fesom_partition_init.F90)
file(GLOB sources_C ${src_home}/*.c)

# generate a custom file from fesom_version_info.F90 which includes the current git SHA
set(FESOM_ORIGINAL_VERSION_FILE ${src_home}/fesom_version_info.F90)
set(FESOM_GENERATED_VERSION_FILE ${CMAKE_CURRENT_BINARY_DIR}/fesom_version_info-generated.F90)
list(REMOVE_ITEM sources_Fortran ${FESOM_ORIGINAL_VERSION_FILE}) # we want to compile the generated file instead
list(APPEND sources_Fortran ${FESOM_GENERATED_VERSION_FILE})
include(GitRepositoryInfo.cmake)

#if(${FESOM_STANDALONE})
#   list(REMOVE_ITEM sources_Fortran ${src_home}/cpl_driver.F90)
#endif()
list(REMOVE_ITEM sources_Fortran ${src_home}/fvom_init.F90)
list(REMOVE_ITEM sources_C       ${src_home}/fort_part.c)

# depends on the metis library
#add_subdirectory(../lib/metis-5.1.0 ${PROJECT_BINARY_DIR}/metis)
#include_directories(../lib/metis-5.1.0/include)
# depends on the parms library
add_subdirectory(../lib/parms ${PROJECT_BINARY_DIR}/parms)

add_subdirectory(async_threads_cpp)

include(${CMAKE_CURRENT_LIST_DIR}/../cmake/FindNETCDF.cmake)

add_library(${PROJECT_NAME}_C ${sources_C})
target_compile_definitions(${PROJECT_NAME}_C PRIVATE PARMS USE_MPI REAL=double DBL HAS_BLAS FORTRAN_UNDERSCORE VOID_POINTER_SIZE_8 SGI LINUX UNDER_ MPI2)
target_link_libraries(${PROJECT_NAME}_C parms) #metis

# create our binary (set its name to name of this project)
add_executable(${PROJECT_NAME} ${sources_Fortran})
target_compile_definitions(${PROJECT_NAME} PRIVATE PARMS -DMETIS_VERSION=5 -DPART_WEIGHTED -DMETISRANDOMSEED=35243)
if(${DISABLE_MULTITHREADING})
   target_compile_definitions(${PROJECT_NAME} PRIVATE DISABLE_MULTITHREADING)
endif()
if(${FESOM_COUPLED})
   include(${CMAKE_CURRENT_LIST_DIR}/../cmake/FindOASIS.cmake)
   target_compile_definitions(${PROJECT_NAME} PRIVATE __oasis)
endif()
if(${OIFS_COUPLED})
   target_compile_definitions(${PROJECT_NAME} PRIVATE __oifs)
endif()
if(${USE_ICEPACK})
   target_compile_definitions(${PROJECT_NAME} PRIVATE __icepack)
endif()
if(${VERBOSE})
   target_compile_definitions(${PROJECT_NAME} PRIVATE VERBOSE)
endif()
# CMAKE_Fortran_COMPILER_ID will also work if a wrapper is being used (e.g. mpif90 wraps ifort -> compiler id is Intel)
if(${CMAKE_Fortran_COMPILER_ID} STREQUAL  Intel )
	target_compile_options(${PROJECT_NAME} PRIVATE -r8 -i4 -fp-model precise -no-prec-div -no-prec-sqrt -fimf-use-svml -xHost -ip -init=zero -no-wrap-margin)
#	target_compile_options(${PROJECT_NAME} PRIVATE -r8 -i4 -fp-model precise -no-prec-div -no-prec-sqrt -fimf-use-svml -xHost -ip -g -traceback -check all,noarg_temp_created,bounds,uninit ) #-ftrapuv ) #-init=zero)
elseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL  GNU )
   if(${FESOM_OPENACC})
	   target_compile_options(${PROJECT_NAME} PRIVATE -O3 -finit-local-zero -finline-functions -march=native -fimplicit-none -fdefault-real-8 -ffree-line-length-none -fopenacc -foffload=nvptx-none="-latomic -lgfortran")
   else()
      target_compile_options(${PROJECT_NAME} PRIVATE -O3 -finit-local-zero -finline-functions -march=native -fimplicit-none -fdefault-real-8 -ffree-line-length-none)
   endif()
   set(CMAKE_EXE_LINKER_FLAGS "-pthread")
   if(CMAKE_Fortran_COMPILER_VERSION VERSION_GREATER_EQUAL 10 )
      target_compile_options(${PROJECT_NAME} PRIVATE -fallow-argument-mismatch) # gfortran v10 is strict about erroneous API calls: "Rank mismatch between actual argument at (1) and actual argument at (2) (scalar and rank-1)"
   endif()
elseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL Cray )
      target_compile_options(${PROJECT_NAME} PRIVATE -c -emf -hbyteswapio -hflex_mp=conservative -hfp1 -hadd_paren -Ounroll0 -hipa0 -r am -s real64 -hnoomp)
elseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL PGI OR ${CMAKE_Fortran_COMPILER_ID} STREQUAL NVHPC)
   if(${FESOM_OPENACC})
       target_compile_options(${PROJECT_NAME} PRIVATE -Mallocatable=95 -Mr8 -pgf90libs -Mnofma -Minfo=all -acc -gpu=${GPU_FLAGS})
       set(CMAKE_EXE_LINKER_FLAGS "-acc -gpu=${GPU_FLAGS}")
   else()
       target_compile_options(${PROJECT_NAME} PRIVATE -Mallocatable=95 -Mr8 -pgf90libs -Mnofma)
   endif()
endif()
target_include_directories(${PROJECT_NAME} PRIVATE ${NETCDF_Fortran_INCLUDE_DIRECTORIES} ${OASIS_Fortran_INCLUDE_DIRECTORIES})
target_include_directories(${PROJECT_NAME} PRIVATE ${MCT_Fortran_INCLUDE_DIRECTORIES} ${MPEU_Fortran_INCLUDE_DIRECTORIES})
target_include_directories(${PROJECT_NAME} PRIVATE ${SCRIP_Fortran_INCLUDE_DIRECTORIES})
target_link_libraries(${PROJECT_NAME} ${PROJECT_NAME}_C ${NETCDF_Fortran_LIBRARIES} ${NETCDF_C_LIBRARIES} ${OASIS_Fortran_LIBRARIES})
target_link_libraries(${PROJECT_NAME} ${PROJECT_NAME}_C ${MCT_Fortran_LIBRARIES} ${MPEU_Fortran_LIBRARIES} ${SCRIP_Fortran_LIBRARIES})
target_link_libraries(${PROJECT_NAME} async_threads_cpp)
set_target_properties(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE Fortran)

set(FESOM_INSTALL_FILEPATH "${CMAKE_CURRENT_LIST_DIR}/../bin/fesom.x" CACHE FILEPATH "file path where the FESOM binary should be put")
get_filename_component(FESOM_INSTALL_PATH ${FESOM_INSTALL_FILEPATH} DIRECTORY)
get_filename_component(FESOM_INSTALL_NAME ${FESOM_INSTALL_FILEPATH} NAME)
install(PROGRAMS ${PROJECT_BINARY_DIR}/${PROJECT_NAME} DESTINATION ${FESOM_INSTALL_PATH} RENAME ${FESOM_INSTALL_NAME})

add_library(settings INTERFACE)

option(OPTIM_ACC_SET_DEVICE "Set the ACC Device to the CPU" OFF)
option(OPTIM_ACC_SET_DEVICE_MPI_BEFORE_ACC_INIT "Set the ACC Device to the CPU: before MPI init" OFF)
option(OPTIM_ACC_SET_DEVICE_SCATTER "Set the ACC Device to the CPU: scatter distribution of GPUs" OFF)
option(OPTIM_ACC_SET_DEVICE_COMPACT "Set the ACC Device to the CPU: compact distribution of GPUs" ON)
if(OPTIM_ACC_SET_DEVICE_SCATTER AND OPTIM_ACC_SET_DEVICE_COMPACT)
	message(FATAL_ERROR "OPTIM_ACC_SET_DEVICE_SCATTER and OPTIM_ACC_SET_DEVICE_COMPACT are mutually exclussive")
endif()

option(WITH_NVTX "Enable the code annotations defined by NVidia Tools Extension (NVTX)" OFF)
#target_compile_features(settings INTERFACE cxx_std_17)

if(WITH_NVTX)
  cmake_policy(VERSION 3.17)
  cmake_policy(SET CMP0074 NEW)

    # https://cmake.org/cmake/help/latest/module/FindCUDAToolkit.html
    find_package(CUDAToolkit REQUIRED)
  if(CUDAToolkit_FOUND)
	  target_link_libraries(settings INTERFACE CUDA::nvToolsExt)
  endif()
endif()
option(WITH_ACC_VECTOR_LENGTH "Enable ACC VECTOR_LENGTH directive" ON)
option(WITH_ACC_ASYNC "Enable ACC ASYNC directive" OFF)

target_compile_definitions(settings
  INTERFACE
  $<$<BOOL:${OPTIM_ACC_SET_DEVICE}>:OPTIM_ACC_SET_DEVICE>
  $<$<AND:$<BOOL:${OPTIM_ACC_SET_DEVICE}>,$<BOOL:${OPTIM_ACC_SET_DEVICE_MPI_BEFORE_ACC_INIT}>>:OPTIM_ACC_SET_DEVICE_MPI_BEFORE_ACC_INIT>
  $<$<AND:$<BOOL:${OPTIM_ACC_SET_DEVICE}>,$<BOOL:${OPTIM_ACC_SET_DEVICE_SCATTER}>>:OPTIM_ACC_SET_DEVICE_SCATTER>
  $<$<AND:$<BOOL:${OPTIM_ACC_SET_DEVICE}>,$<BOOL:${OPTIM_ACC_SET_DEVICE_COMPACT}>>:OPTIM_ACC_SET_DEVICE_COMPACT>
  $<$<BOOL:${WITH_NVTX}>:WITH_NVTX>

  $<$<BOOL:${WITH_ACC_VECTOR_LENGTH}>:WITH_ACC_VECTOR_LENGTH>
  $<$<BOOL:${WITH_ACC_ASYNC}>:WITH_ACC_ASYNC>
)
target_link_libraries(${PROJECT_NAME} settings)


